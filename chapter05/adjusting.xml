<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../general.ent">
  %general-entities;
]>

<sect1 id="ch-tools-adjusting">
  <?dbhtml filename="adjusting.html"?>

<!--E
  <title>Adjusting the Toolchain</title>
-->
  <title>调整工具链</title>

<!--E
  <para>Now that the temporary C libraries have been installed, all
  tools compiled in the rest of this chapter should be linked against
  these libraries. In order to accomplish this, the linker and the
  compiler's specs file need to be adjusted.</para>
-->
  <para>现在，安装好了 C 语言的临时库，本章中剩余章节所有要编译的工具都要链接到这些库文件上。为此，需要调整连接器和编译器的工程设计(specs)文件。</para>

<!--E
  <para>The linker, adjusted at the end of the first pass of Binutils, needs
  to be renamed so that it can be properly found and used. First, backup the
  original linker, then replace it with the adjusted linker. We'll also
  create a link to its counterpart in <filename class="directory">
  /tools/$(gcc -dumpmachine)/bin</filename>:</para>
-->
  <para>在第一遍编译 Binutils 结束时已经调整过的连接器，现在需要被重新命名以便可以被正确的找到和使用。首先备份原来的连接器，然后用调整过的连接器来替代，最后还要创建一个指向 <filename class="directory">/tools/$(gcc -dumpmachine)/bin </filename> 中连接器副本的连接。</para>

<screen><userinput>mv -v /tools/bin/{ld,ld-old}
mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}
mv -v /tools/bin/{ld-new,ld}
ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</userinput></screen>

<!--E
  <para>From this point onwards, everything will link only against the
  libraries in <filename class="directory">/tools/lib</filename>.</para>
-->
  <para>从现在开始，所有的程序都将链接到 <filename class="directory">/tools/lib</filename> 目录下的库文件。</para>

<!--E
  <para>The next task is to point GCC to the new dynamic linker. This is done by
  dumping GCC's <quote>specs</quote> file to a location where GCC will look for it
  by default. A simple <command>sed</command> substitution then alters the
  dynamic linker that GCC will use.</para>
-->
  <para>下面的任务是修改 GCC 的 <quote>specs</quote> 文件，使 GCC 可以默认指向新的动态链接器。一个简单的 <command>sed</command> 代换就可以做到：</para>

<!--E
  <para>For the sake of accuracy, it is recommended to use a copy-and-paste
  method when issuing the following command. Be sure to visually inspect the
  specs file and verify that all occurrences of <quote>/lib/ld-linux.so.2</quote>
  have been replaced with <quote>/tools/lib/ld-linux.so.2</quote>:</para>
-->
  <para>为了准备起见，推荐使用复制粘贴的办法来应用下面的命令。请亲眼确认下 specs 文件，保证每一处<quote>/lib/ld-linux.so.2</quote>都被替换成了<quote>/tools/lib/ld-linux.so.2</quote>：</para>

  <important>
<!--E
    <para>If working on a platform where the name of the dynamic linker is
    something other than <filename class="libraryfile">ld-linux.so.2</filename>,
    replace <quote>ld-linux.so.2</quote> with the name of the platform's
    dynamic linker in the following commands. Refer to <xref
    linkend="ch-tools-toolchaintechnotes" role=","/> if necessary.</para>
-->
    <para>如果你的系统平台上的动态链接器名字不是 <filename class="libraryfile">ld-linux.so.2</filename>，请将下面命令中的<quote>ld-linux.so.2</quote>替换为相应的动态链接器名称。如果需要，请参阅<xref linkend="ch-tools-toolchaintechnotes" role=","/>。</para>
  </important>

<!-- Ampersands are needed to allow copy and paste -->
<screen><userinput>gcc -dumpspecs | sed 's@/lib/ld-linux.so.2@/tools&amp;@g' \
  > `dirname $(gcc -print-libgcc-file-name)`/specs</userinput></screen>

<!--E
  <para>During the build process, GCC runs a script
  (<command>fixincludes</command>) that scans the system for header files
  that may need to be fixed (they might contain syntax errors, for example),
  and installs the fixed versions in a private include directory. There is a
  possibility that, as a result of this process, some header files from the
  host system have found their way into GCC's private include directory. As
  the rest of this chapter only requires the headers from GCC and Glibc,
  which have both been installed at this point, any <quote>fixed</quote>
  headers can safely be removed. This helps to avoid any host headers
  polluting the build environment. Run the following commands to remove the
  header files in GCC's private include directory (you may find it easier to
  copy and paste these commands, rather than typing them by hand, due to
  their length):</para>
-->
  <para>在编译过程中，GCC 会运行 fixincludes 脚本来扫描系统头文件目录，并找出需要修正的头文件（比如包含语法错误），然后把修正后的文件放到 GCC 专属头文件目录里。因此，它可能会找出宿主系统中需要修正的头文件，并将修正后的结果放到 GCC 专属头文件目录里。由于本章的剩余部分仅需要使用当前已经安装好的 GCC 和 Glibc 的头文件，所以任何<quote>修正后的</quote>头文件都可以被安全的删除。并且这样做也有助于避免宿主系统中的头文件污染编译环境。运行下面的命令删除 GCC 专属头文件目录中的头文件(由于命令较长，推荐你拷贝和粘贴命令，而不是手动输入)：</para>

<!-- && used to ease copy and pasting -->
<screen><userinput>GCC_FIXED=`dirname $(gcc -print-libgcc-file-name)`/include-fixed &amp;&amp;
find ${GCC_FIXED}/* -maxdepth 0 -xtype d -exec rm -rvf '{}' \; &amp;&amp;
rm -vf `grep -l "DO NOT EDIT THIS FILE" ${GCC_FIXED}/*` &amp;&amp;
unset GCC_FIXED</userinput></screen>

  <caution>
<!--E
    <para>At this point, it is imperative to stop and ensure that the basic
    functions (compiling and linking) of the new toolchain are working as
    expected. To perform a sanity check, run the following commands:</para>
-->
    <para>现在，有必要停下来检查新工具链能够完成预期功能（编译和链接），运行下面命令完成合理的检查：</para>

<screen><userinput>echo 'main(){}' &gt; dummy.c
cc dummy.c
readelf -l a.out | grep ': /tools'</userinput></screen>

<!--E
    <para>If everything is working correctly, there should be no errors,
    and the output of the last command will be of the form:</para>
-->
    <para>如果工作一切正常，应该不会出错，最后一个命令的输出应该是：</para>

<screen><computeroutput>[Requesting program interpreter:
    /tools/lib/ld-linux.so.2]</computeroutput></screen>

<!--E
    <para>Note that <filename class="directory">/tools/lib</filename>
    appears as the prefix of the dynamic linker.</para>
-->
    <para>注意，<filename class="directory">/tools/lib</filename> 应该是动态链接器的前缀。</para>

<!--E
    <para>If the output is not shown as above or there was no output at all,
    then something is wrong. Investigate and retrace the steps to find out
    where the problem is and correct it. This issue must be resolved before
    continuing on. First, perform the sanity check again, using
    <command>gcc</command> instead of <command>cc</command>. If this works,
    then the <filename class="symlink">/tools/bin/cc</filename> symlink is
    missing. Revisit <xref linkend="ch-tools-gcc-pass1" role=","/> and install
    the symlink. Next, ensure that the <envar>PATH</envar> is correct. This
    can be checked by running <command>echo $PATH</command> and verifying that
    <filename class="directory">/tools/bin</filename> is at the head of the
    list. If the <envar>PATH</envar> is wrong it could mean that you are not
    logged in as user <systemitem class="username">lfs</systemitem> or that
    something went wrong back in <xref linkend="ch-tools-settingenviron"
    role="."/> Another option is that something may have gone wrong with the
    specs file amendment above. In this case, redo the specs file amendment,
    being careful to copy-and-paste the commands.</para>
-->
    <para>如果输出和上面的不一样，或者根本没有输出，就一定是出错了。返回前面的步骤查找为标题所在，在纠正这个问题之前不要继续往下做。首先，重新做上一个检查，但用 <command>gcc</command> 替换 <command>cc</command>，如果这次输出正确了，说明链接到 <command>cc</command> 的符号链接有问题，返回<xref linkend="ch-tools-gcc-pass1" role=","/>创建符号链接。下一步，确保 <envar>PATH</envar> 变量的正确，这可以通过运行 <command>echo $PATH</command>，验证 <filename class="directory">/tools/bin</filename>是否在输出列表的最开头。如果 <envar>PATH</envar> 变量出错，可能是因为你不是作为 <systemitem class="username">lfs</systemitem> 用户登入，也可能是在做<xref linkend="ch-tools-settingenviron" role="."/>出错了。另外一个原因可能是上面修正 specs 文件时出错，如果这样，重新修改 specs 文件，复制粘贴时要小心仔细。</para>

<!--E
    <para>Once all is well, clean up the test files:</para>
-->
    <para>一切正常之后，清理测试文件：</para>

<screen><userinput>rm -v dummy.c a.out</userinput></screen>

  </caution>

<!--E
  <note><para>Building Tcl in the next section will serve as an additional check that
  the toolchain has been built properly.  If Tcl fails to build, it is an
  indication that something has gone wrong with the Binutils, GCC, or Glibc
  installation, but not with Tcl itself.</para></note>
-->
  <note><para>下一节编译 Tcl 时为了验证工具链构建正确而做的附加检验工具。如果 Tcl 编译失败，错误出在 Binutils、GCC、或者 Glibc 的安装，而不是 Tcl 本身。</para></note>

</sect1>
